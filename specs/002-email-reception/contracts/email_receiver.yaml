# API Contract: EmailReceiver

version: "1.0.0"
feature: "002-email-reception"
component: "EmailReceiver"
created: "2025-10-30"
status: "Design"

# Overview
# --------
# EmailReceiver is responsible for retrieving emails from the portfolioupdates@signite.co
# inbox and saving them as RawEmail entities. It provides an abstract interface with
# concrete implementations for Gmail API with Webhook (Cloud Pub/Sub) push notifications.
#
# This contract defines the interface that all EmailReceiver implementations must follow.

# Requirements Coverage
# ---------------------
# FR-001: Connect to inbox with configurable authentication
# FR-002: Retrieve unprocessed emails in chronological order
# FR-003: Save raw email content with timestamp and unique ID
# FR-009: Log all processing activities with timestamps
# FR-010: Handle connection failures with exponential backoff (max 3 retries)
# FR-011: Detect duplicate emails using message ID
# SC-001: Retrieve 90%+ of emails within 5 minutes

---

# Abstract Interface

interface: EmailReceiver
description: |
  Abstract base class for email ingestion implementations.
  All implementations must inherit from this interface and implement the required methods.

methods:
  # -------------------------------------------------------------------------
  # Method: fetch_emails
  # -------------------------------------------------------------------------
  - name: fetch_emails
    description: |
      Retrieve unprocessed emails from the inbox in chronological order.
      This is the primary method for email ingestion.

    requirements:
      - FR-002  # Retrieve unprocessed emails in chronological order
      - FR-011  # Detect duplicates using message ID

    input:
      parameters:
        - name: since
          type: datetime
          required: false
          description: |
            Only retrieve emails received after this timestamp.
            If None, retrieve all unprocessed emails.
          default: null

        - name: max_emails
          type: int
          required: false
          description: |
            Maximum number of emails to retrieve in one batch.
            Useful for rate limiting and pagination.
          default: 100
          constraints:
            min: 1
            max: 500

    output:
      success:
        type: List[RawEmail]
        description: |
          List of RawEmail objects in chronological order (oldest first).
          Empty list if no new emails found.
        example: |
          [
            RawEmail(
              metadata=EmailMetadata(
                message_id="<CABc123@mail.gmail.com>",
                sender="partner@example.com",
                subject="CollabIQ 협업 업데이트",
                received_at="2025-10-30T14:35:22Z",
                retrieved_at="2025-10-30T14:36:00Z",
                has_attachments=False
              ),
              body="안녕하세요,\n\n프로젝트 진행 상황을 공유드립니다.\n\n감사합니다.",
              attachments=[]
            )
          ]

      errors:
        - code: CONNECTION_FAILED
          description: |
            Failed to connect to email service after max retries.
            Implements FR-010 exponential backoff (3 retries).
          retry_strategy:
            max_attempts: 3
            backoff_type: exponential
            base_delay_seconds: 2
            max_delay_seconds: 30
          example: |
            EmailReceiverError(
              code="CONNECTION_FAILED",
              message="Failed to connect to Gmail API after 3 retries",
              retry_count=3,
              last_error="HTTPError: 503 Service Unavailable"
            )

        - code: AUTHENTICATION_FAILED
          description: |
            Invalid credentials or expired OAuth token.
            No retry - requires user intervention.
          retry_strategy:
            max_attempts: 0
          example: |
            EmailReceiverError(
              code="AUTHENTICATION_FAILED",
              message="OAuth token expired or invalid",
              retry_count=0,
              last_error="google.auth.exceptions.RefreshError"
            )

        - code: RATE_LIMIT_EXCEEDED
          description: |
            Email service rate limit exceeded.
            Implements exponential backoff with longer delays.
          retry_strategy:
            max_attempts: 3
            backoff_type: exponential
            base_delay_seconds: 60
            max_delay_seconds: 600
          example: |
            EmailReceiverError(
              code="RATE_LIMIT_EXCEEDED",
              message="Gmail API rate limit exceeded",
              retry_count=2,
              retry_after_seconds=120
            )

        - code: INVALID_RESPONSE
          description: |
            Email service returned malformed response.
            Single retry with short delay.
          retry_strategy:
            max_attempts: 1
            backoff_type: fixed
            base_delay_seconds: 5

    side_effects:
      - Logs ProcessingEvent.EMAIL_RETRIEVED for each email (FR-009)
      - Logs ProcessingEvent.DUPLICATE_DETECTED for skipped emails (FR-011)
      - Logs ProcessingEvent.CONNECTION_FAILED on errors (FR-010)
      - Logs ProcessingEvent.CONNECTION_RETRY for retry attempts (FR-010)
      - Updates DuplicateTracker.processed_message_ids (FR-011)

  # -------------------------------------------------------------------------
  # Method: save_raw_email
  # -------------------------------------------------------------------------
  - name: save_raw_email
    description: |
      Save RawEmail to file storage with timestamp and message ID.
      Creates monthly subdirectories automatically.

    requirements:
      - FR-003  # Save raw email content with timestamp and unique ID

    input:
      parameters:
        - name: email
          type: RawEmail
          required: true
          description: The RawEmail object to save

    output:
      success:
        type: Path
        description: |
          Path to the saved JSON file.
        example: |
          Path("/Users/jlim/Projects/CollabIQ/data/raw/2025/10/20251030_143622_CABc123.json")

      errors:
        - code: STORAGE_FAILED
          description: |
            Failed to write email to file storage.
            No retry - likely filesystem permission issue.
          retry_strategy:
            max_attempts: 0
          example: |
            EmailReceiverError(
              code="STORAGE_FAILED",
              message="Permission denied writing to /data/raw/2025/10/",
              retry_count=0,
              last_error="PermissionError: [Errno 13]"
            )

        - code: VALIDATION_FAILED
          description: |
            RawEmail failed Pydantic validation.
            No retry - data quality issue.
          retry_strategy:
            max_attempts: 0
          example: |
            EmailReceiverError(
              code="VALIDATION_FAILED",
              message="Invalid RawEmail: message_id cannot be empty",
              retry_count=0,
              validation_errors=["message_id: field required"]
            )

    side_effects:
      - Creates monthly directory if it doesn't exist (data/raw/YYYY/MM/)
      - Writes JSON file with format YYYYMMDD_HHMMSS_{message_id}.json
      - Logs ProcessingEvent.EMAIL_RETRIEVED on success

  # -------------------------------------------------------------------------
  # Method: is_duplicate
  # -------------------------------------------------------------------------
  - name: is_duplicate
    description: |
      Check if an email has already been processed using message ID.
      Uses DuplicateTracker to maintain set of processed IDs.

    requirements:
      - FR-011  # Detect duplicate emails using message ID

    input:
      parameters:
        - name: message_id
          type: str
          required: true
          description: Email message ID to check

    output:
      success:
        type: bool
        description: |
          True if message_id exists in DuplicateTracker.processed_message_ids,
          False otherwise.
        example: |
          True  # Email already processed
          False  # New email

      errors:
        - code: TRACKER_LOAD_FAILED
          description: |
            Failed to load DuplicateTracker from file.
            Single retry attempt.
          retry_strategy:
            max_attempts: 1
            backoff_type: fixed
            base_delay_seconds: 1

    side_effects:
      - Loads DuplicateTracker from data/metadata/processed_ids.json
      - No modifications to tracker (read-only operation)

  # -------------------------------------------------------------------------
  # Method: mark_processed
  # -------------------------------------------------------------------------
  - name: mark_processed
    description: |
      Mark an email as processed by adding message ID to DuplicateTracker.

    requirements:
      - FR-011  # Track processed emails to prevent duplicates

    input:
      parameters:
        - name: message_id
          type: str
          required: true
          description: Email message ID to mark as processed

    output:
      success:
        type: None
        description: |
          No return value. Raises exception on failure.

      errors:
        - code: TRACKER_SAVE_FAILED
          description: |
            Failed to save DuplicateTracker to file.
            Single retry attempt.
          retry_strategy:
            max_attempts: 1
            backoff_type: fixed
            base_delay_seconds: 1

    side_effects:
      - Updates DuplicateTracker.processed_message_ids set
      - Updates DuplicateTracker.last_updated timestamp
      - Writes updated tracker to data/metadata/processed_ids.json

---

# Concrete Implementation: GmailWebhookReceiver

implementation: GmailWebhookReceiver
extends: EmailReceiver
description: |
  Gmail API implementation with Cloud Pub/Sub webhook for push notifications.
  This is the recommended implementation for production use (SC-001: 5-minute retrieval).

configuration:
  required:
    - GMAIL_CREDENTIALS_PATH
      type: Path
      description: Path to OAuth2 credentials JSON file from Google Cloud Console
      example: "/app/config/gmail_credentials.json"

    - GMAIL_TOKEN_PATH
      type: Path
      description: Path to store OAuth2 access/refresh tokens
      example: "/app/config/gmail_token.json"

    - GMAIL_PUBSUB_TOPIC
      type: str
      description: Google Cloud Pub/Sub topic name for email notifications
      example: "projects/collabiq/topics/gmail-notifications"

    - GMAIL_INBOX_LABEL
      type: str
      description: Gmail label to filter emails (use "INBOX" for all)
      default: "INBOX"

  optional:
    - GMAIL_API_SCOPES
      type: List[str]
      description: Gmail API OAuth scopes
      default: ["https://www.googleapis.com/auth/gmail.readonly"]

    - GMAIL_MAX_RESULTS
      type: int
      description: Maximum emails per API call
      default: 100
      constraints:
        min: 1
        max: 500

authentication:
  method: OAuth2
  flow: |
    1. First run: User authorizes app via browser (gets credentials.json)
    2. App exchanges credentials for access/refresh tokens (saves to token.json)
    3. Subsequent runs: App uses refresh token to get new access tokens automatically
    4. If refresh token expires: User must re-authorize (AUTHENTICATION_FAILED error)

webhook_setup:
  method: Cloud Pub/Sub Push Subscription
  description: |
    Gmail sends push notifications to Pub/Sub topic when new emails arrive.
    Cloud Run service receives webhook, triggers fetch_emails().

  steps:
    - step: 1
      action: Enable Gmail API and Pub/Sub API in Google Cloud Console

    - step: 2
      action: Create Pub/Sub topic
      command: |
        gcloud pubsub topics create gmail-notifications

    - step: 3
      action: Grant Gmail permission to publish to topic
      command: |
        gcloud pubsub topics add-iam-policy-binding gmail-notifications \
          --member=serviceAccount:gmail-api-push@system.gserviceaccount.com \
          --role=roles/pubsub.publisher

    - step: 4
      action: Create push subscription pointing to Cloud Run service
      command: |
        gcloud pubsub subscriptions create gmail-push-sub \
          --topic=gmail-notifications \
          --push-endpoint=https://collabiq-email-receiver-xxx.run.app/webhook/gmail \
          --push-auth-service-account=collabiq-webhook@project.iam.gserviceaccount.com

    - step: 5
      action: Set up Gmail watch request (renew every 7 days)
      code: |
        service.users().watch(
          userId='me',
          body={
            'topicName': 'projects/collabiq/topics/gmail-notifications',
            'labelIds': ['INBOX']
          }
        ).execute()

performance:
  latency:
    push_notification: "< 5 seconds"  # Gmail → Pub/Sub → Cloud Run
    api_fetch: "< 10 seconds"  # fetch_emails() call
    total_ingestion: "< 15 seconds"  # End-to-end (SC-001: within 5 minutes ✅)

  rate_limits:
    gmail_api:
      quota: "1 billion quota units/day"
      messages_list: "5 units per call"
      messages_get: "5 units per call"
      daily_capacity: "~100 million emails/day"  # Far exceeds 50 emails/day requirement

    pubsub:
      quota: "No hard limit for push subscriptions"
      message_size: "10 MB max"
      throughput: "Thousands of messages/second"

dependencies:
  python_packages:
    - google-auth==2.23.0
    - google-auth-oauthlib==1.1.0
    - google-auth-httplib2==0.1.1
    - google-api-python-client==2.100.0
    - google-cloud-pubsub==2.18.4

error_handling:
  retry_logic: |
    def fetch_emails(self, since=None, max_emails=100):
        retry_count = 0
        max_retries = 3
        base_delay = 2

        while retry_count <= max_retries:
            try:
                # Call Gmail API
                results = service.users().messages().list(...).execute()
                return self._parse_messages(results)

            except HttpError as e:
                if e.resp.status == 401:  # Auth failed
                    raise EmailReceiverError(code="AUTHENTICATION_FAILED", ...)

                if e.resp.status == 429:  # Rate limit
                    retry_count += 1
                    delay = min(60 * (2 ** retry_count), 600)  # Exponential with cap
                    self._log_retry(retry_count, delay)
                    time.sleep(delay)

                elif e.resp.status >= 500:  # Server error
                    retry_count += 1
                    delay = base_delay * (2 ** retry_count)
                    self._log_retry(retry_count, delay)
                    time.sleep(delay)

                else:
                    raise EmailReceiverError(code="INVALID_RESPONSE", ...)

        raise EmailReceiverError(code="CONNECTION_FAILED", retry_count=retry_count)

---

# Testing Contract

test_requirements:
  unit_tests:
    - test_fetch_emails_success:
        description: Verify fetch_emails returns RawEmail list in chronological order
        mock: Gmail API list() and get() responses
        assertions:
          - returned_emails is sorted by received_at (oldest first)
          - all emails have valid RawEmail structure
          - duplicate emails are filtered out

    - test_fetch_emails_connection_failed:
        description: Verify exponential backoff retry on connection failure
        mock: Gmail API raises HttpError 503 (Service Unavailable)
        assertions:
          - retries 3 times with increasing delays (2s, 4s, 8s)
          - raises EmailReceiverError(code="CONNECTION_FAILED")
          - logs ProcessingEvent.CONNECTION_RETRY for each retry

    - test_fetch_emails_auth_failed:
        description: Verify no retry on authentication failure
        mock: Gmail API raises HttpError 401 (Unauthorized)
        assertions:
          - does NOT retry
          - raises EmailReceiverError(code="AUTHENTICATION_FAILED")
          - logs error immediately

    - test_save_raw_email_success:
        description: Verify RawEmail is saved to correct file path
        assertions:
          - file created at data/raw/YYYY/MM/YYYYMMDD_HHMMSS_{message_id}.json
          - monthly directory created if missing
          - file contains valid JSON matching RawEmail schema

    - test_is_duplicate_true:
        description: Verify duplicate detection works
        setup: Add message_id to DuplicateTracker
        assertions:
          - is_duplicate(message_id) returns True

    - test_is_duplicate_false:
        description: Verify new email detection works
        setup: Empty DuplicateTracker
        assertions:
          - is_duplicate(new_message_id) returns False

  integration_tests:
    - test_gmail_api_oauth_flow:
        description: Verify OAuth2 authentication works end-to-end
        requires: Real Gmail API credentials
        steps:
          - Load credentials.json
          - Authenticate user (browser flow)
          - Save token.json
          - Verify access token is valid

    - test_gmail_webhook_notification:
        description: Verify Pub/Sub webhook triggers email fetch
        requires: Cloud Pub/Sub emulator or test topic
        steps:
          - Send test email to inbox
          - Wait for Pub/Sub notification
          - Verify fetch_emails() is triggered
          - Verify email is saved to data/raw/

  contract_tests:
    - test_interface_compliance:
        description: Verify GmailWebhookReceiver implements all EmailReceiver methods
        assertions:
          - has method fetch_emails(since, max_emails)
          - has method save_raw_email(email)
          - has method is_duplicate(message_id)
          - has method mark_processed(message_id)

---

# Example Usage

example_basic:
  description: Basic email fetching
  code: |
    from email_receiver import GmailWebhookReceiver
    from config.settings import settings

    # Initialize receiver with OAuth credentials
    receiver = GmailWebhookReceiver(
        credentials_path=settings.gmail_credentials_path,
        token_path=settings.gmail_token_path
    )

    # Fetch emails since yesterday
    since = datetime.now() - timedelta(days=1)
    emails = receiver.fetch_emails(since=since, max_emails=50)

    # Save each email
    for email in emails:
        if not receiver.is_duplicate(email.metadata.message_id):
            path = receiver.save_raw_email(email)
            receiver.mark_processed(email.metadata.message_id)
            print(f"Saved: {path}")
        else:
            print(f"Skipped duplicate: {email.metadata.message_id}")

example_webhook_handler:
  description: Cloud Run webhook endpoint
  code: |
    from flask import Flask, request
    from email_receiver import GmailWebhookReceiver

    app = Flask(__name__)
    receiver = GmailWebhookReceiver(...)

    @app.route('/webhook/gmail', methods=['POST'])
    def handle_gmail_notification():
        """
        Receives Pub/Sub push notification when new Gmail arrives.
        Notification format: {'message': {'data': base64_encoded_json}}
        """
        notification = request.get_json()
        # Pub/Sub sends notification, but we still need to fetch emails
        # (notification doesn't contain email content, just a trigger)

        try:
            emails = receiver.fetch_emails(max_emails=10)
            for email in emails:
                if not receiver.is_duplicate(email.metadata.message_id):
                    receiver.save_raw_email(email)
                    receiver.mark_processed(email.metadata.message_id)

            return {'status': 'success', 'processed': len(emails)}, 200

        except EmailReceiverError as e:
            return {'status': 'error', 'message': str(e)}, 500

example_error_handling:
  description: Handling connection failures
  code: |
    from email_receiver import GmailWebhookReceiver, EmailReceiverError

    receiver = GmailWebhookReceiver(...)

    try:
        emails = receiver.fetch_emails()
    except EmailReceiverError as e:
        if e.code == "CONNECTION_FAILED":
            # Log to monitoring system
            logger.error(f"Gmail API connection failed after {e.retry_count} retries")
            # Alert on-call engineer
            alert_service.send(f"CollabIQ email ingestion down: {e.message}")

        elif e.code == "AUTHENTICATION_FAILED":
            # Requires user to re-authorize
            logger.critical("Gmail OAuth token expired - manual intervention required")
            alert_service.send_urgent("CollabIQ OAuth token needs renewal")

        elif e.code == "RATE_LIMIT_EXCEEDED":
            # Wait and retry later
            logger.warning(f"Gmail rate limit hit - retry in {e.retry_after_seconds}s")
            time.sleep(e.retry_after_seconds)

---

# Contract Compliance

requirements_coverage:
  FR-001: ✅ Configurable authentication via OAuth2 (credentials_path, token_path)
  FR-002: ✅ fetch_emails() retrieves in chronological order
  FR-003: ✅ save_raw_email() creates files with timestamp and message ID
  FR-009: ✅ ProcessingLogEntry created for all activities
  FR-010: ✅ Exponential backoff retry (3 max) in fetch_emails()
  FR-011: ✅ is_duplicate() and mark_processed() implement duplicate detection
  SC-001: ✅ Webhook push notifications achieve < 15 second ingestion (< 5 min target)

success_criteria_validation:
  SC-001: |
    Gmail API with Pub/Sub webhooks achieves < 15 second end-to-end latency:
    - Gmail → Pub/Sub notification: < 5 seconds
    - Pub/Sub → Cloud Run trigger: < 5 seconds
    - fetch_emails() API call: < 10 seconds
    - Total: < 20 seconds (well within 5-minute target ✅)

edge_cases_handled:
  - Empty inbox: fetch_emails() returns empty list (no error)
  - Invalid credentials: Raises AUTHENTICATION_FAILED immediately (no retry)
  - Duplicate emails: is_duplicate() filters before processing
  - Rate limits: Exponential backoff with longer delays (60s base)
  - Network failures: Exponential backoff with 3 retries
  - Malformed response: Single retry then INVALID_RESPONSE error

---

**Document Status**: Complete - Ready for implementation
